.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Seq::PrimedSeq::Plus 3pm"
.TH Bio::Seq::PrimedSeq::Plus 3pm "2009-02-24" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  Bio::Seq::PrimedSeq::Plus \- perl (bioperl) class to store a primed sequence along with information about BLAST results for the primers and thermodynamic parameters for both the primers and the amplicon
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  Extends Bio::Seq::PrimedSeq, which isa SeqFeature.
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments and suggestions preferably to one of the Bioperl mailing lists. Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General Discussion
\&  http://www.bioperl.org/MailList.html   \- About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track of the bugs and their resolution. Bug reports can be submitted via the web:
.PP
.Vb 1
\&  http://bugzilla.open\-bio.org/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Cass Johnston
.PP
caroline.johnston@iop.kcl.ac.uk
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
None yet but any offers of help would be gratefully accepted.
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal methods are usually preceeded by a _
.Sh "new"
.IX Subsection "new"
.Vb 1
\&  As for Bio::Seq::PrimedSeq
.Ve
.Sh "coerce"
.IX Subsection "coerce"
.Vb 3
\&  A number of bioperl tools, notable Primer3, return 
\&  PrimedSeq objects. This method allows you to coerce 
\&  them into PrimedSeq::Plus objects
.Ve
.Sh "mfe_left_primer"
.IX Subsection "mfe_left_primer"
.Vb 2
\&  If called with no params, returns the results of the last
\&  call to the Unafold MFE folding algorithm hybrid\-ss\-min
\&
\&  I called with params, will attempt to run hybrid\-ss\-min
\&  on the left primer sequence, passing any parameters to the 
\&  mfe algorithm.
.Ve
.Sh "left_mfe_params"
.IX Subsection "left_mfe_params"
.Vb 2
\&  Returns a hashref of the params used for the last
\&  run of MFE. Or undef if it hasn\*(Aqt yet been run.
.Ve
.Sh "mfe_right_primer"
.IX Subsection "mfe_right_primer"
.Vb 1
\&  As for mfe_left_primer, but on the right primer
.Ve
.Sh "right_mfe_params"
.IX Subsection "right_mfe_params"
.Vb 2
\&  Returns a hashref of the params used for the last
\&  run of MFE. Or undef if it hasn\*(Aqt yet been run.
.Ve
.Sh "mfe_amplicon"
.IX Subsection "mfe_amplicon"
.Vb 1
\& As for mfe_left_primer, but for the entire amplicon.
.Ve
.Sh "amp_mfe_params"
.IX Subsection "amp_mfe_params"
.Vb 2
\&  Returns a hashref of the params used for the last
\&  run of MFE. Or undef if it hasn\*(Aqt yet been run.
.Ve
.Sh "mfe_tms_under"
.IX Subsection "mfe_tms_under"
.Vb 1
\&  if($obj\->mfe_tms_under(threshold=>60, folding_temp=>37)){...}
\&
\&  Checks to see if the Tm values given by the MFE folding of
\&  both primers and the amplicon are all over the given threshold 
\&  at the given temperature.
\&
\&  Warns and returns undef if any of the Tms are undefined 
\&  (ie if the folding hasn\*(Aqt been done yet). 
\& 
\&  Otherwise returns boolean 1 or 0.
\&
\&  if no temp value is passed as an argument, the tmin
\&  from the mfe call is used.
.Ve
.Sh "_blast_defaults"
.IX Subsection "_blast_defaults"
.Vb 3
\&  An internal method that returns a hash of blast params
\&  which have sensible defaults. (probably should be based on 
\&  type of sequence, primer design task and so on.)
.Ve
.Sh "blast_left_primer"
.IX Subsection "blast_left_primer"
.Vb 3
\&  If called with no arguments, returns the results of the last
\&  blast on the left primer. This may be undef if a blast has 
\&  yet to be run.
\&
\&  If called with run=>true, it will attempt to run a remote 
\&  blast on the left primer, passing any other arguments to the 
\&  remote blast interface (see the documentation for 
\&  Bio::Tools::Run::RemoteBlast
\&
\&  There are sensible (ymmv) defaults, so you can just do
\&   $obj\->blast_left_primer(run=>1)
.Ve
.Sh "left_blast_rid"
.IX Subsection "left_blast_rid"
.Vb 2
\& returns the Retrieval ID of the last blast job on the
\& left primer
.Ve
.Sh "left_blast_params"
.IX Subsection "left_blast_params"
.Vb 2
\&  A get method for the set of parameters passed to the
\&  last blast to be run on the left primer.
\&
\&  Returns results as a list of key, value pairs which can 
\&  be put into a hash or handed direct to another blast call.
\&
\&  my %params = $obj\->left_blast_params
\&  $obj\->blast_right_primer($obj\->left_blast_params);
.Ve
.Sh "blast_right_primer"
.IX Subsection "blast_right_primer"
.Vb 1
\&  As for blast_left_primer, but for the right primer.
.Ve
.Sh "right_blast_rid"
.IX Subsection "right_blast_rid"
.Vb 2
\& returns the Retrieval ID of the last blast job on the
\& right primer
.Ve
.Sh "right_blast_params"
.IX Subsection "right_blast_params"
.Vb 2
\&  As for left_blast_params, but for the last blast run on
\&  the right primer.
.Ve
.Sh "blast_amplicon"
.IX Subsection "blast_amplicon"
.Vb 2
\&  As for blast_left_primer, but for the whole amplicon
\&  sequence (including primers)
\&
\&  Probably not really necessary, as blasting the primers
\&  should be enough to pick up any problem sequences but
\&  included for completeness.
.Ve
.Sh "amplicon_blast_rid"
.IX Subsection "amplicon_blast_rid"
.Vb 2
\& returns the Retrieval ID of the last blast job on the
\& amplicon
.Ve
.Sh "amplicon_blast_params"
.IX Subsection "amplicon_blast_params"
.Vb 2
\&  As for left_blast_params, but for the last blast run
\&  on the amplicon.
.Ve
.Sh "blast_url"
.IX Subsection "blast_url"
.Vb 2
\&  Given a retrieval ID, will return the URL to retrieve
\&  that data using the NCBI web interface
\&
\&  Makes no attempt to check whether the result is till 
\&  stored on the NCBI server.
.Ve
.Sh "left_blast_url"
.IX Subsection "left_blast_url"
.Vb 2
\&  Returns the URL of the results page for the  last BLAST
\&  on the left primer. Or undef if there isn\*(Aqt one yet.
.Ve
.Sh "right_blast_url"
.IX Subsection "right_blast_url"
.Vb 1
\&  As above but for right primer
.Ve
.Sh "amplicon_url"
.IX Subsection "amplicon_url"
.Vb 1
\&  As above but for the amplicon
.Ve
.Sh "blast_conflicts"
.IX Subsection "blast_conflicts"
.Vb 7
\&  The blast results will tell you if a primer is hitting 
\&  a non\-target region. A moderate level of homology with
\&  a non\-target region may cause some competition for the 
\&  primer and it may not be an ideal choice, however if you 
\&  are constrained in your primer choice (for example if you
\&  are designing tiled primers) you may not wish to throw
\&  out a primer on this basis alone.
\&
\&  Of far more serious concern is the case in which both
\&  primers have non\-target hits close together, which could
\&  potentially result in amplification of a non\-target region
\&
\&  blast_conflicts will check the results of the left and right
\&  primer blasts and will return 1 if there are any conflicts, 0
\&  otherwise
\&
\&
\&  By default, a conflict is any instance where the primers hit
\&  closer than 4k bases. This can be changed with the min_separation 
\&  parameter although more than this is unlikely to cause problems
\&  in the time available for elongation in a normal pcr.
\&
\&  my @conflicts = $obj\->blast_conflicts(min_separation => \*(Aq4000\*(Aq);
.Ve
.Sh "_genomic_dbs"
.IX Subsection "_genomic_dbs"
.Vb 1
\&  returns a hashref to a  map of species name to genomic db id.
.Ve
.Sh "repeat_dbs"
.IX Subsection "repeat_dbs"
.Vb 1
\& returns a hashref to a map of species name to repeat db id.
.Ve
.Sh "species"
.IX Subsection "species"
.Vb 3
\&  Accessor for the species we are dealing with.
\&  Options are currently: human, mouse, rat, dog, cat
\&  cow, chimp, macaca
.Ve
